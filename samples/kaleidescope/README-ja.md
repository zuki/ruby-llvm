Kaleidoscope
--------------

Kaleidoscopeは、llvm.orgのチュートリアルで実装されているおもちゃ言語です。 チュートリアルは、http://llvm.org/docs/tutorial/ にあります。

これは1000行で書かれたオリジナルソースのrubyポートですが、構文（c++ -> ruby​​）の変更とともに、次のような変更を加えています。

- グローバル変数は使用していません。 レキサー（字句解析器）、パーサー（構文解析器）、ドライバ(main)はクラスにしました。
- Tokenクラスは、レキサーでトークン列を連結リストのように見せるために使用されています。
- 外部c関数は定義できないので、簡単なput()をドライバで定義しています。

チュートリアルはオンラインで読むことができますが、とても良くできています。

総論
-------

コードに付け加えるものは何もありませんが、少しだけ説明します。

Kaleidoscopeには1つのタイプ(float)しかありません。単項演算子と二項演算子の構築にはそれで十分ですが、独自に演算子を定義することができます。以下を参照してください。 任意の数の引数を持つ関数の定義や関数の呼び出しができます。 if文とforループもあります。

プログラムの構造
----------------

ドライバはmain関数です。そこでは必要な（llvmの概念である）モジュールとパーサーをインスタンス化します。 また、put関数の定義もしています。

入力ソースが正常にパースされると、実行され、stdoutに書き込まれます。 関数の外に書いたステートメントは、無名関数にラップされて実行されます。

最後に、モジュールをstderrに出力します（これは定義されたすべての関数です）。詳細は以下を参照してください

パーサーは、トークンをASTオブジェクトに変換する関数の集合です。これは再帰下降パーサーと呼ばれるものであり、コードを追うのは簡単です。

構文木
-----------

ExprASTから派生したクラスのインスタンスは、Kaleidoscopeプログラムを表現する内部構造である構文木を構成します。 各クラスは自身を表す少数の記述を持っていますが（演算子を除いて）どれも極めて自明なものです。新しい演算子は、`def binary&`で定義できます。ここで、`&`は任意の記号で、演算子を表します。 優先順位も定義することができます（初心者向けのチュートリアルとしては少しやりすぎかもしれません）。

rubyバインドでは各ノードに`to_s`を追加しました。これにより、コードを取り出すことができます。 これは、何が評価されたのかを示すのに使用されています。

もちろんastノードには自身を表すコードを生成する責任があります。 関数`code()`は、llvm機構の中心的要素である`LLVM::Value`を返します。 `Value`は命令または数値を表す定数式です。これらはllvmでは`BasicBlocks`と呼ばれるグループにまとめられます。ブロックはプログラムのフローグラフと考えることができます。

LLVMの階層
-----------------

code()関数が何をするものであるかを理解するには、llvmをより良く理解することが役に立ちます。そのためには、読んで、読んで、読みまくることです。しかし、ここでは簡単に紹介します。

**Module**はコンパイルの単位です。グローバルな値と関数を含んでいます。Rubyでは列挙可能なコレクションとして保持します。

**Function**は**Parameter**と**BasicBlock**のリストを持ちます。これらもイテレートすることができます。また、ブロックを「構築する」ためのブロックスタイル構文があります。先に示したように、ブロックは「フローチャート」であり、そのようなグラフをリストとして扱うことは少し混乱するかもしれません。場合によっては、明示的に "挿入ポイント"を設定する必要があります。

ブロックは命令群で構成されますが、それは実際には値（LLVM::Valueの派生物）群を意味します。ブロック間のフローは**明示的に**作成される必要があることを理解することが重要です。 順番に作成されるブロックであっても、「暗黙の」フローは存在しません。無条件分岐である"br"を追加する必要があります。

一連の命令/値を「構築」するには3つの方法があります。 最も単純なものは定数です。たとえば、`LLVM::Int(0)`は整数0を表す定数値です。DoubleとIntX（Xは1,8,32,64）が存在します。 LLVMは強く型付けされており、比較結果（1ビット）から32ビットのintを取得したい場合は、（ビルダーが持つxx2xxで）キャストする必要があります。

もう一つの方法は、ビルダー（class Builder）を使用して命令を作成する方法です。ビルダーは非常にたくさんあります（私も全部は知りません）が、基本的なものには,
`mul`（乗算）、`add`、`icmp`（整数比較）、`fcmp`、`ret`（return）があります。この方法は、ruby-llvmが持つブロックapiを使うとさらに便利です。`module.functions.add do ||` と書くことで、関数とビルダーを取得できます。

同様に`function.basic_blocks.append(name).build do ||` と書くことでビルダーを取得できます。

最後の方法は、値自体を使用することです。ビルダーと同様な関数である`add`や`cmp`が値にも存在し、`left.add(right)`と行った形で呼び出すことができます。

最後にphiノードについて言及したいと思います。現代のプログラミング言語にはこれと同等のものがないからです。phiはある種の逆分岐です。条件分岐（builder.cond）をファンアウトであると考えると、phiは逆向きのファンです。phiは多くの入力ブロックを持ち、フローがどこから来たのかによって異なる値を取ります。この説明にうんざりしなかったら、gepやibrが何であるかを調べてください。

Kaleidoscopeのスクリプトを実行する
-----------------------------

Kaleidoscopeスクリプトは、次の方法で実行できます。

```ruby
bundle exec ruby samples/kaleidescope/driver.rb  samples/kaleidescope/maths.kal
```

スクリプトを作成する場合は、関数ではなく式で終了する必要があります。これは、最後に関数があっても何ができるかを考えれば自然とわかるはずです。しかし、これを忘れて関数でスクリプトを終えてしまった場合は、関数のシグネチャが一致しないというエラーになります。

また、ファイルを省略してインタラクティブにコードを入力することもできます。コードを評価するには`ctr-d`を入力する必要があります。

実行可能ファイル
-----------

はい、可能です！ 制限はありますが、払い戻しはありません。最後の式を表すcのmain関数が生成されます。最後は関数ではなく式でなければなりません（そうでなければ関数シグネチャが一致しません）。 ただし、"Evaluated to"メッセージはRubyドライバが出力していることを覚えておいてください。あなたのプログラムが出力するのは、プログラムが作成したもの、つまりputしたものだけです。

まず、`.kal`ファイルを実行し、モジュールをファイルに出力します。 モジュールはstderrに出力されます。例えば次を実行すると

```ruby
bundle exec ruby samples/kaleidescope/driver.rb  samples/kaleidescope/mandel.kal 2> mandel.ll
```

mandelモジュールをllvm irファイルとして取得できます。

このファイルは2つの方法で実行できます。一つはllvmインタプリタ、lliを使う方法です。

```bash
lli mandel.ll
```

これは実際にモジュールをそのまま実行します。あなたが`put`したもの以外は出力されないことを思い出してください。 もう一つの方法は次です。

```bash
llc -O3 mandel.ll -filetype=obj -o mandel.o
gcc mandel.o -o mandel
./mandel
```

追伸: 最高に楽しむためには、timeまたはls -lを使ってください。結果として作成されるプログラムには約8キロバイトのオーバヘッドがあるので、mandelは数百バイトです。 そして、階乗計算（出力なし）は、lliのインタープリタ方式と比べてexeでは約20倍速く実行されます。
